import streamlit as st
import psycopg2
from psycopg2.extras import RealDictCursor
import google.generativeai as genai
import json
import time
import tempfile
import os
from datetime import datetime
import random
import string
import re
from docx import Document
import fitz  
import base64
import requests
import time
import json
st.set_page_config(page_title="Adaptive Quiz & Course System", layout="wide")
if 'selected_language' not in st.session_state:
    st.session_state.selected_language = 'English'  # default

language = st.selectbox(
    "üåê Choose your preferred language for the quiz and course:",
    ["English", "Hindi", "Telugu", "Kannada"]
)
st.session_state.selected_language = language
DB_CONFIG = {
    'host': 'localhost',
    'database': 'AI_2',
    'user': 'postgres',
    'password': '123456',
    'port': '5432'
}
GEMINI_API_KEY_QUIZ = "API KEY" 
GEMINI_API_KEY_VIVA = "API KEY"
GEMINI_API_KEY_AGENT1 = "API KEY"  # Pre-assessment 
GEMINI_API_KEY_AGENT2 = "API KEY"  # Mini quiz
GEMINI_API_KEY_AGENT3 = "API KEY"  # Weekly quiz
GEMINI_API_KEY_AGENT4 = "API KEY"  # Overall performance
GEMINI_API_KEY_AGENT5 = "API KEY"  # Course fetch
GEMINI_API_KEY_AGENT6 = "API KEY"  # Trend fetch
GEMINI_API_KEY_SUPER = "API KEY"   # Final course
TAVUS_API_KEY = "API KEY"
def get_agent1_model():
    genai.configure(api_key=GEMINI_API_KEY_AGENT1)
    return genai.GenerativeModel('gemini-2.0-flash')
def get_agent2_model():
    genai.configure(api_key=GEMINI_API_KEY_AGENT2)
    return genai.GenerativeModel('gemini-2.0-flash')
def get_agent3_model():
    genai.configure(api_key=GEMINI_API_KEY_AGENT3)
    return genai.GenerativeModel('gemini-2.0-flash')
def get_agent4_model():
    genai.configure(api_key=GEMINI_API_KEY_AGENT4)
    return genai.GenerativeModel('gemini-2.0-flash')
def get_agent5_model():
    genai.configure(api_key=GEMINI_API_KEY_AGENT5)
    return genai.GenerativeModel('gemini-2.0-flash')
def get_agent6_model():
    genai.configure(api_key=GEMINI_API_KEY_AGENT6)
    return genai.GenerativeModel('gemini-2.0-flash')
def get_super_agent_model():
    genai.configure(api_key=GEMINI_API_KEY_SUPER)
    return genai.GenerativeModel('gemini-2.0-flash')
def get_viva_model():
    genai.configure(api_key=GEMINI_API_KEY_VIVA)
    return genai.GenerativeModel('gemini-2.0-flash')
AVAILABLE_COURSES = [
    "Data Science using Python", 
    "Machine Learning with Python", 
    "Generative AI Application Development",
    "Data Analysis and Visualization with Python"
]
def get_db_connection():
    """Create and return a database connection"""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        return conn
    except psycopg2.Error as e:
        st.error(f"Database connection error: {e}")
        return None
def create_tavus_video(api_key, script, replica_id="r660c4f3ba"):
    """Initiates video generation using the Tavus API."""
    headers = {
        "x-api-key": api_key,
        "Content-Type": "application/json"
    }
    url = "https://tavusapi.com/v2/videos"
    payload = {
        "replica_id": replica_id,
        "script": script
    }
    try:
        response = requests.post(url, json=payload, headers=headers)
        response.raise_for_status()  # Will raise an exception for HTTP error codes
        return response.json()
    except requests.exceptions.RequestException as e:
        st.error(f"Error creating Tavus video: {e}")
        return None

def check_tavus_video_status(api_key, video_id):
    """Checks the status of a video being generated by the Tavus API."""
    headers = {"x-api-key": api_key}
    url = f"https://tavusapi.com/v2/videos/{video_id}"
    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        st.error(f"Error checking Tavus video status: {e}")
        return None
def create_data_table():
    """Create data table for file storage"""
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()
        create_data_query = """
        CREATE TABLE IF NOT EXISTS data (
            id SERIAL PRIMARY KEY,
            roll_no VARCHAR(20) NOT NULL,
            file_name VARCHAR(255) NOT NULL,
            file_type VARCHAR(50) NOT NULL,
            file_data TEXT NOT NULL,
            file_summary TEXT,
            uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (roll_no) REFERENCES pre_assessment(roll_no) ON DELETE CASCADE
        );"""
        cursor.execute(create_data_query)
        conn.commit()
        cursor.close()
        conn.close()
        return True
    except psycopg2.Error as e:
        st.error(f"Error creating data table: {e}")
        if conn:
            conn.close()
        return False
def save_file_data(roll_no, file_name, file_type, file_content, file_summary):
    """Save file data and summary to database"""
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()
        file_data_encoded = base64.b64encode(file_content).decode('utf-8')       
        insert_query = """
        INSERT INTO data (roll_no, file_name, file_type, file_data, file_summary)
        VALUES (%s, %s, %s, %s, %s)
        """
        cursor.execute(insert_query, (roll_no, file_name, file_type, file_data_encoded, file_summary))
        conn.commit()
        cursor.close()
        conn.close()
        return True
    except psycopg2.Error as e:
        st.error(f"Error saving file data: {e}")
        if conn:
            conn.close()
        return False
def summarize_file_content(content, file_type):
    """Generate summary of file content using Gemini Viva API"""
    viva_model = get_viva_model()
    max_content_length = 30000  
    if len(content) > max_content_length:
        content = content[:max_content_length] + "... [Content truncated]"   
    prompt = f"""
    Please provide a comprehensive summary of the following {file_type} file content:    
    Content:
    {content}   
    Please provide:
    1. Main topics covered
    2. Key points and highlights
    3. Important concepts or findings
    4. Overall theme or purpose
    5. Any actionable insights
    
    Format the summary in a clear, structured manner.
    """    
    try:
        response = viva_model.generate_content(prompt)
        return response.text
    except Exception as e:
        st.error(f"Error generating summary: {e}")
        return f"Summary generation failed for {file_type} file. Error: {str(e)}"
def extract_text_from_file(uploaded_file):
    """Extract text content from various file formats"""
    file_type = uploaded_file.type
    file_content = uploaded_file.read()   
    try:
        if file_type == "text/plain":
            return file_content.decode('utf-8'), "text"
        elif file_type == "application/pdf":
            with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp:
                tmp.write(file_content)
                tmp_path = tmp.name
            try:
                pdf_doc = fitz.open(tmp_path)
                full_text = ""
                for page in pdf_doc:
                    full_text += page.get_text()
                pdf_doc.close()
                return full_text, "pdf"
            except Exception as e:
                return f"Error reading PDF: {str(e)}", "pdf"
            finally:
                os.remove(tmp_path)
        elif file_type in ["application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/msword"]:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".docx") as tmp:
                tmp.write(file_content)
                tmp_path = tmp.name
            try:
                doc = Document(tmp_path)
                full_text = "\n".join([para.text for para in doc.paragraphs])
                return full_text, "word"
            except Exception as e:
                return f"Error reading Word document: {str(e)}", "word"
            finally:
                os.remove(tmp_path)
        elif file_type == "text/csv":
            return file_content.decode('utf-8'), "csv"
        elif file_type == "application/json":
            return file_content.decode('utf-8'), "json"
        elif file_type == "text/x-python":
            return file_content.decode('utf-8'), "python"
        elif file_type == "text/markdown":
            return file_content.decode('utf-8'), "markdown"
        else:
            try:
                return file_content.decode('utf-8'), "unknown"
            except UnicodeDecodeError:
                return "Binary file format not supported. Please use text-based files.", "binary"               
    except Exception as e:
        return f"Error extracting content: {str(e)}", "error"
def get_student_data(roll_no):
    """Fetches student data from the pre_assessment table."""
    conn = get_db_connection()
    if conn is None:
        return {}
    try:
        cursor = conn.cursor(cursor_factory=RealDictCursor)
        cursor.execute("SELECT * FROM pre_assessment WHERE roll_no = %s", (roll_no,))
        student_data = cursor.fetchone()
        cursor.close()
        conn.close()
        return student_data if student_data else {}
    except psycopg2.Error as e:
        st.error(f"Error fetching student data: {e}")
        if conn:
            conn.close()
        return {}
def file_upload_section():
    st.header("üìÅ File Upload & Analysis")

    if 'roll_no' not in st.session_state or not st.session_state.roll_no:
        st.error("Please complete the assessment sections first to get your roll number.")
        return

    st.write(f"**Student Roll No:** {st.session_state.roll_no}")

    # Initialize session state for file analysis results
    if 'file_analyzed' not in st.session_state:
        st.session_state.file_analyzed = False
    if 'uploaded_file_info' not in st.session_state:
        st.session_state.uploaded_file_info = None
    if 'generated_summary' not in st.session_state:
        st.session_state.generated_summary = ""
    if 'generated_video_script' not in st.session_state:
        st.session_state.generated_video_script = ""
    if 'current_video_id' not in st.session_state:
        st.session_state.current_video_id = None

    uploaded_file = st.file_uploader(
        "Choose a file to upload and analyze",
        type=['txt', 'pdf', 'docx', 'doc', 'csv', 'json', 'py', 'md'],
        help="Supported formats: Text files, PDF, Word documents, CSV, JSON, Python files, Markdown"
    )

    if uploaded_file is not None:
        st.write(f"**File Name:** {uploaded_file.name}")
        st.write(f"**File Type:** {uploaded_file.type}")
        st.write(f"**File Size:** {uploaded_file.size} bytes")

        if st.session_state.uploaded_file_info is None or \
           st.session_state.uploaded_file_info.get("name") != uploaded_file.name or \
           st.button("Analyze File", key="analyze_new_file"):

            with st.spinner("Processing file and generating summary..."):
                text_content, content_type = extract_text_from_file(uploaded_file)

                if "Error" in text_content or "not implemented" in text_content:
                    st.error(text_content)
                    return

                summary = summarize_file_content(text_content, content_type)
                uploaded_file.seek(0)
                file_content = uploaded_file.read()

                student = get_student_data(st.session_state.roll_no)
                domain = student.get("domain", "Data Science")
                present_domain = student.get("present_domain", "business domain")
                interested_field = student.get("interested_field", "their field")
                student_name = student.get("name", "the learner")

                with st.spinner("üé• Generating video script and prompt..."):
                    video_output = generate_video_script_from_course_profile(
                        summary,
                        present_domain,
                        interested_field,
                        student_name
                    )

                if save_file_data(st.session_state.roll_no, uploaded_file.name,
                                uploaded_file.type, file_content, summary):
                    st.session_state.generated_summary = summary
                    st.session_state.generated_video_script = video_output
                    st.session_state.uploaded_file_info = {
                        "name": uploaded_file.name,
                        "type": uploaded_file.type,
                        "content_type": content_type
                    }
                    st.session_state.file_analyzed = True
                    st.session_state.current_video_id = None
                    st.success("‚úÖ File uploaded and analyzed successfully!")
                    st.rerun()
                else:
                    st.error("Failed to save file data to database.")
    
    if st.session_state.file_analyzed and st.session_state.generated_summary and st.session_state.generated_video_script:
        st.markdown("### üìã File Summary")
        st.markdown(st.session_state.generated_summary)

        st.markdown("### üé¨ Video Prompt & Script")
        st.markdown(st.session_state.generated_video_script)

        st.download_button(
            label="üì• Download Video Script",
            data=st.session_state.generated_video_script,
            file_name=f"video_script_{st.session_state.uploaded_file_info['name']}.txt",
            mime="text/plain",
            key="download_script_button"
        )
        
        st.download_button(
            label="üì• Download Summary",
            data=st.session_state.generated_summary,
            file_name=f"summary_{st.session_state.uploaded_file_info['name']}.txt",
            mime="text/plain",
            key="download_summary_button"
        )

        if st.button("üé¨ Generate Video from Script", key="generate_video_button"):
            script_text = ""
            video_output = st.session_state.generated_video_script

            if "## üìù Script:" in video_output:
                script_text = video_output.split("## üìù Script:")[1].strip()
            else:
                script_text = video_output

            if script_text:
                lines = script_text.split('\n')
                if len(lines) > 3:
                    script_text = "\n".join(lines[:3])
                    st.warning("‚ö†Ô∏è Script truncated to the first 3 lines to accommodate API limits.")

            if not script_text:
                st.error("Could not extract a script from the generated content.")
            else:
                with st.spinner("Sending script to video generator..."):
                    create_response = create_tavus_video(TAVUS_API_KEY, script_text)

                    if create_response and create_response.get("video_id"):
                        video_id = create_response["video_id"]
                        st.session_state.current_video_id = video_id
                        st.success(f"‚úÖ Video generation started! Video ID: `{video_id}`")
                        st.write("‚è≥ Waiting for video to be ready... This can take a few minutes.")

                        video_url = None
                        max_attempts = 60
                        
                        for attempt in range(max_attempts):
                            status_response = check_tavus_video_status(TAVUS_API_KEY, video_id)
                            
                            if status_response and 'status' in status_response:
                                status = status_response.get("status")
                                st.info(f"Video status: '{status}' (Attempt {attempt + 1}/{max_attempts})")

                                # MODIFIED: Check for both 'completed' and 'ready' statuses
                                if status == "completed" or status == "ready":
                                    video_url = status_response.get("download_url")
                                    if video_url: # Ensure download_url is actually present
                                        st.success("üéâ Your video is ready!")
                                        st.video(video_url)
                                        break
                                    else:
                                        # If status is 'ready'/'completed' but no URL, wait for a few more attempts
                                        st.warning("Video status is ready, but download URL not yet available. Waiting...")
                                        if attempt == max_attempts - 1: # If last attempt and still no URL
                                            st.error("Video is ready but download URL did not become available.")
                                            break
                                        time.sleep(5) # Give it a moment to appear
                                elif status == "failed":
                                    error_message = status_response.get('error', 'Unknown error')
                                    st.error(f"üö´ Video creation failed: {error_message}")
                                    break
                            else:
                                st.warning("Could not retrieve video status. Will retry...")

                            time.sleep(5)

                        if not video_url: # If loop finished without getting video_url
                            st.warning("‚è∞ Video is still processing or failed.")
                            if st.session_state.get('current_video_id'):
                                if st.button("Manually Check Video Status", key="manual_check_status_button_action"):
                                    st.info(f"Checking status for Video ID: `{st.session_state.current_video_id}`...")
                                    manual_status_response = check_tavus_video_status(TAVUS_API_KEY, st.session_state.current_video_id)
                                    if manual_status_response and 'status' in manual_status_response:
                                        manual_status = manual_status_response.get("status")
                                        st.write(f"**Current Video Status:** `{manual_status}`")
                                        if manual_status == "completed" or manual_status == "ready": # Also check for 'ready' here
                                            manual_video_url = manual_status_response.get("download_url")
                                            if manual_video_url:
                                                st.success("üéâ Video is now ready!")
                                                st.video(manual_video_url)
                                            else:
                                                st.warning("Video is ready but download URL not yet available. Please check Tavus dashboard.")
                                        elif manual_status == "failed":
                                            st.error(f"üö´ Video creation failed: {manual_status_response.get('error', 'Unknown error')}")
                                        else:
                                            st.info("Video is still processing.")
                                    else:
                                        st.error("Could not retrieve manual video status. Please try again or check Tavus dashboard.")
                                    
                                    st.markdown(f"**Tavus Dashboard (if applicable):** [Tavus](https://tavus.com/)")
                    else:
                        error_msg = create_response.get("error", "Unknown error from API") if create_response else "No response from API"
                        st.error(f"üö´ Failed to start video creation: {error_msg}")
def generate_video_script_from_course_profile(course_text, present_domain, interested_field, student_name="the learner"):
    prompt = f"""
üé¨ You are an expert educational scriptwriter for animated learning videos.

You‚Äôre creating a short video script for a learner named **{student_name}**.

üìò Personalized Course Content:
{course_text}

üë§ Learner‚Äôs Profile:
- Field of Interest: {interested_field}
- Currently Working In: {present_domain}

---

üéØ TASK:
1. Generate a creative and engaging script explaining the **core ideas of this course**.
2. Show **how this knowledge is applicable in their current domain ({present_domain})**.
3. Highlight **why this course matters** for their interest in {interested_field}.
4. Make it easy to follow, practical, and a bit inspiring.

---

‚úÖ Output Format:

## üé• Video Prompt:
Brief animation / style instructions for visual creators (e.g., ‚ÄúWhiteboard + 2D explainer with practical field examples‚Äù)

## üìù Script:
Step-by-step narration, include friendly transitions, domain-specific analogies, and clear explanations. Conclude with a motivational call to action for learners from {present_domain}.
"""
    model = get_super_agent_model()
    try:
        response = model.generate_content(prompt)
        return response.text.strip()
    except Exception as e:
        return f"Error generating video script from course: {e}"
def create_tables():
    """Create database tables"""
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()        
        create_pre_assessment_query = """
        CREATE TABLE IF NOT EXISTS pre_assessment (
            roll_no VARCHAR(20) PRIMARY KEY,
            date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            name VARCHAR(255) NOT NULL,
            domain VARCHAR(255) NOT NULL,
            present_domain VARCHAR(255),
            interested_field VARCHAR(255),
            qualification VARCHAR(255),
            years_experience INTEGER,
            preferred_difficulty VARCHAR(50),
            formal_training VARCHAR(10),
            hours_per_day INTEGER DEFAULT 3,
            weeks INTEGER DEFAULT 4,
            knowledge_scale INTEGER,
            current_week_no INTEGER DEFAULT 1,
            cognitive_score INTEGER DEFAULT 0,
            cognitive_iq INTEGER DEFAULT 0,
            domain_score INTEGER DEFAULT 0,
            domain_iq INTEGER DEFAULT 0,
            viva_score INTEGER DEFAULT 0,
            viva_response TEXT DEFAULT '',
            course_configured BOOLEAN DEFAULT FALSE
        );"""            
        create_week_quiz_query = """
        CREATE TABLE IF NOT EXISTS week_quiz (
            id SERIAL PRIMARY KEY,
            roll_no VARCHAR(20) REFERENCES pre_assessment(roll_no) ON DELETE CASCADE,
            week_no INTEGER NOT NULL,
            week_quiz_score INTEGER DEFAULT 0,
            week_quiz_iq INTEGER DEFAULT 0,
            strong_areas TEXT,
            weak_areas TEXT,
            analysis TEXT,
            date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(roll_no, week_no)
        );"""       
        create_course_content_query = """
        CREATE TABLE IF NOT EXISTS course_content (
            id SERIAL PRIMARY KEY,
            roll_no VARCHAR(20) REFERENCES pre_assessment(roll_no) ON DELETE CASCADE,
            week_no INTEGER NOT NULL,
            course_content TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(roll_no, week_no)
        );"""        
        create_overall_performance_query = """
        CREATE TABLE IF NOT EXISTS overall_performance (
            roll_no VARCHAR(20) PRIMARY KEY REFERENCES pre_assessment(roll_no) ON DELETE CASCADE,
            topics_excellented TEXT,
            outcome_of_course TEXT,
            student_progress TEXT,
            last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );"""
        create_data_query = """
        CREATE TABLE IF NOT EXISTS data (
            id SERIAL PRIMARY KEY,
            roll_no VARCHAR(20) NOT NULL,
            file_name VARCHAR(255) NOT NULL,
            file_type VARCHAR(50) NOT NULL,
            file_data TEXT NOT NULL,
            file_summary TEXT,
            uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (roll_no) REFERENCES pre_assessment(roll_no) ON DELETE CASCADE
        );"""       
        create_mini_quiz_query = """
        CREATE TABLE IF NOT EXISTS mini_quiz (
            id SERIAL PRIMARY KEY,
            roll_no VARCHAR(20) REFERENCES pre_assessment(roll_no) ON DELETE CASCADE,
            week_no INTEGER NOT NULL,
            topic_no INTEGER NOT NULL,
            topic_name TEXT NOT NULL,
            quiz_score INTEGER DEFAULT 0,
            date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE (roll_no, week_no, topic_no)
        );"""
        cursor.execute(create_pre_assessment_query)
        cursor.execute(create_mini_quiz_query)
        cursor.execute(create_week_quiz_query)
        cursor.execute(create_course_content_query)
        cursor.execute(create_overall_performance_query)
        cursor.execute(create_data_query)  
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS agent_data (
            roll_no VARCHAR(20) PRIMARY KEY REFERENCES pre_assessment(roll_no) ON DELETE CASCADE,
            pre_assessment JSONB,
            mini_quiz JSONB,
            weekly_quiz JSONB,
            overall_performance JSONB,
            course_fetch TEXT,
            trend_fetch TEXT
        );
        """)
        conn.commit()
        cursor.close()
        conn.close()
        return True
    except psycopg2.Error as e:
        st.error(f"Error creating tables: {e}")
        if conn:
            conn.close()
        return False
def run_agent_pre_assessment(roll_no):
    conn = get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    cursor.execute("SELECT * FROM pre_assessment WHERE roll_no = %s", (roll_no,))
    data = cursor.fetchone()
    if data:
        data_serializable = {k: (v.isoformat() if isinstance(v, datetime) else v) for k, v in data.items()}
        prompt = f"Summarize this student's background:\n{json.dumps(data_serializable, indent=2)}"
        summary = get_agent1_model().generate_content(prompt).text.strip()
        cursor.execute("""
            INSERT INTO agent_data (roll_no, pre_assessment)
            VALUES (%s, %s)
            ON CONFLICT (roll_no) DO UPDATE SET pre_assessment = EXCLUDED.pre_assessment
        """, (roll_no, json.dumps({"summary": summary})))
        conn.commit()
    cursor.close()
    conn.close()
def run_agent_mini_quiz(roll_no):
    conn = get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    cursor.execute("SELECT week_no, topic_name, quiz_score FROM mini_quiz WHERE roll_no = %s", (roll_no,))
    data = cursor.fetchall()
    if data:
        data_serializable = []
        for row in data:
            fixed_row = {k: (v.isoformat() if isinstance(v, datetime) else v) for k, v in row.items()}
            data_serializable.append(fixed_row)
        prompt = f"""
        Analyze student quiz scores:\n{json.dumps(data_serializable, indent=2)}
        """
        model = get_agent2_model()
        summary = model.generate_content(prompt).text.strip()
        cursor.execute("UPDATE agent_data SET mini_quiz = %s WHERE roll_no = %s", (json.dumps({"summary": summary}), roll_no))
        conn.commit()
    cursor.close()
    conn.close()
def run_agent_weekly_quiz(roll_no):
    conn = get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    cursor.execute("SELECT * FROM week_quiz WHERE roll_no = %s", (roll_no,))
    data = cursor.fetchall()
    if data:
        data_serializable = []
        for row in data:
            fixed_row = {k: (v.isoformat() if isinstance(v, datetime) else v) for k, v in row.items()}
            data_serializable.append(fixed_row)
        prompt = f"""
        Identify weekly quiz trends:\n{json.dumps(data_serializable, indent=2)}
        """
        model = get_agent3_model()
        summary = model.generate_content(prompt).text.strip()
        cursor.execute("UPDATE agent_data SET weekly_quiz = %s WHERE roll_no = %s", (json.dumps({"summary": summary}), roll_no))
        conn.commit()
    cursor.close()
    conn.close()
def run_agent_overall_performance(roll_no):
    conn = get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    cursor.execute("SELECT * FROM overall_performance WHERE roll_no = %s", (roll_no,))
    data = cursor.fetchone()
    if data:
        data_serializable = {k: (v.isoformat() if isinstance(v, datetime) else v) for k, v in data.items()}
        prompt = f"""
        Summarize this student's overall performance in 2 lines:

        {json.dumps(data_serializable, indent=2)}
        """
        model = get_agent4_model()
        summary = model.generate_content(prompt).text.strip()
        cursor.execute("UPDATE agent_data SET overall_performance = %s WHERE roll_no = %s", (json.dumps({"summary": summary}), roll_no))
        conn.commit()
    cursor.close()
    conn.close()
def run_agent_course_fetch(roll_no):
    course_text = "Python Basics, Functions, OOP, APIs"
    prompt = f"Choose 3 most important topics from:\n{course_text}"
    summary = get_agent5_model().generate_content(prompt).text.strip()
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("UPDATE agent_data SET course_fetch = %s WHERE roll_no = %s", (summary, roll_no))
    conn.commit()
    cursor.close()
    conn.close()
def run_agent_trend_fetch(roll_no):
    trends = "Generative AI, Data Ethics, Prompt Engineering"
    prompt = f"Pick top trends for a beginner course:\n{trends}"
    summary = get_agent6_model().generate_content(prompt).text.strip()
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("UPDATE agent_data SET trend_fetch = %s WHERE roll_no = %s", (summary, roll_no))
    conn.commit()
    cursor.close()
    conn.close()
def run_super_agent_generate_course(roll_no):
    conn = get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    cursor.execute("SELECT * FROM agent_data WHERE roll_no = %s", (roll_no,))
    agent_data = cursor.fetchone()
    cursor.close()
    conn.close()

    if not agent_data:
        return "No agent data found."

    # Extract values safely before using them in the prompt
    domain = agent_data.get("pre_assessment", {}).get("domain", "Data Science")
    present_domain = agent_data.get("pre_assessment", {}).get("present_domain", "their business domain")

    prompt = f"""
Using the following student profile and performance data, generate a detailed, fun, and *domain-specific* course that is **tailored for the student's actual field of work**.

üìå Student Data:
{json.dumps(agent_data, indent=2)}

üéØ Objective:
Design a **deeply personalized course** in **{domain}**, aimed at solving real problems in **{present_domain}** (e.g., logistics, finance, education, healthcare, etc.).

üß† Key Requirements:
- The course must relate every topic **directly to the student's business/domain**.
- Add **practical, real-life examples**, even **funny metaphors** if needed.
- Make it feel like a friendly mentor is teaching.
- Emphasize *problem-solving* and *application in their field*.
- The course should be structured in modules, not weeks. Each module must clearly explain:
    - Why this topic is relevant to the student's current domain ({present_domain})
    - How it is implemented in that field
    - Real-world examples
    - How the student can apply it directly in their work or projects
    - Include domain-specific use cases and examples
    - Tips on implementation at work

üìö Format:
Organize content as modules. For each:

**Module Title: <name>**
1. Summary of the topic.
2. 2‚Äì3 paragraphs of beginner-to-advanced explanation.
3. **1‚Äì2 real-world examples** directly from the student's field (like route optimization in transport or fraud detection in finance).
4. **1 funny or relatable analogy** to reinforce the concept (like "clustering is like sorting your socks by color and size").
5. End each module with a motivational note: "Try applying this to ___ in your own business!"

üß© Example:
**Module 1: Introduction to Data Science in Transport**
Explanation about DS basics.
Example: "Predicting demand on different city routes."
Funny note: "Think of your buses like hungry kids‚Äîyou need to feed them data at the right time!"
...

üí° Bonus:
If applicable, include tips on open-source tools and automation relevant to their business type.

üõë Don't repeat basic definitions unnecessarily.
‚úÖ DO make it specific to {present_domain}.
"""

    model = get_super_agent_model()
    try:
        response = model.generate_content(prompt)
        final_course = response.text.strip()
        save_course_content(roll_no, 1, final_course)
        return final_course
    except Exception as e:
        return f"Gemini error: {e}"
def generate_mini_quiz(topic, domain):
    quiz_model = get_quiz_model()
    prompt = f"""Generate 1 mini quiz (MCQ) for the topic: '{topic}' in the {domain} domain.
Return JSON:
[{{"question_text": "...", "question_type": "mcq", "options": ["A", "B", "C", "D"], "correct_answer": "The full text of the correct answer", "explanation": "..."}}]"""
    try:
        response = quiz_model.generate_content(prompt)
        json_data = json.loads(response.text[response.text.find('['):response.text.rfind(']')+1])
        return json_data[0]
    except Exception as e:
        st.error(f"Failed to generate mini-quiz: {e}")
        return None
def save_mini_quiz_result(roll_no, week_no, topic_no, topic_name, quiz_score):
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO mini_quiz (roll_no, week_no, topic_no, topic_name, quiz_score)
            VALUES (%s, %s, %s, %s, %s)
            ON CONFLICT (roll_no, week_no, topic_no)
            DO UPDATE SET quiz_score = EXCLUDED.quiz_score, date = CURRENT_TIMESTAMP
        """, (roll_no, week_no, topic_no, topic_name, quiz_score))
        conn.commit()
        cursor.close()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Error saving mini quiz: {e}")
        return False
def generate_roll_no(domain, branch="CSE"):
    """Generate sequential roll number based on domain"""
    current_year = datetime.now().year % 100   
    domain_codes = {
        "data science using python": "DP",
        "machine learning with python": "MP",
        "generative ai application development": "GA",
        "data analysis and visualization with python": "DV"
    } 
    domain_lower = domain.lower()
    course_code = domain_codes.get(domain_lower, "GN")   
    conn = get_db_connection()
    if conn:
        try:
            cursor = conn.cursor()
            pattern = f"{current_year}{course_code}%{branch}"
            cursor.execute("""
                SELECT roll_no FROM pre_assessment 
                WHERE roll_no LIKE %s 
                ORDER BY roll_no DESC LIMIT 1
            """, (pattern,))
            result = cursor.fetchone()           
            if result:
                last_roll = result[0]
                seq_part = last_roll.split(course_code)[1][:3]
                next_seq = int(seq_part) + 1
            else:
                next_seq = 1           
            cursor.close()
            conn.close()          
            roll_no = f"{current_year}{course_code}{next_seq:03d}{branch}"
            return roll_no           
        except Exception as e:
            st.error(f"Error generating roll number: {e}")
            if conn:
                conn.close()
            return f"{current_year}{course_code}001{branch}"   
    return f"{current_year}{course_code}001{branch}"    
def save_pre_assessment(data):
    """Save pre-assessment data to database"""
    conn = get_db_connection()
    if conn is None:
        return None
    try:
        roll_no = generate_roll_no(data['domain'])
        cursor = conn.cursor()       
        insert_query = """
        INSERT INTO pre_assessment (
            roll_no, name, domain, present_domain, interested_field, qualification,
            years_experience, preferred_difficulty, formal_training,
            hours_per_day, weeks, knowledge_scale,
            current_week_no, cognitive_score, cognitive_iq, domain_score, domain_iq
        ) VALUES (
            %s, %s, %s, %s, %s, %s,
            %s, %s, %s,
            %s, %s, %s,
            %s, %s, %s, %s, %s
        )
        """
        cursor.execute(insert_query, (
            roll_no,
            data.get('name', ''),
            data.get('domain', ''),
            data.get('present_domain', ''),
            data.get('interested_field', ''),
            data.get('qualification', ''),
            data.get('years_experience', 0),
            data.get('preferred_difficulty', 'Medium'),
            data.get('formal_training', 'No'),
            data.get('hours_per_day', 3),
            data.get('weeks', 4),
            data.get('knowledge_scale', 2),
            1,
            data.get('cognitive_score', 0),
            data.get('cognitive_iq', 0),
            data.get('domain_score', 0),
            data.get('domain_iq', 0)
        ))        
        cursor.execute("""
            INSERT INTO overall_performance (roll_no, topics_excellented, outcome_of_course, student_progress)
            VALUES (%s, %s, %s, %s)
        """, (roll_no, '', 'Course started', 'Initial assessment completed'))        
        conn.commit()
        cursor.close()
        conn.close()
        return roll_no
    except psycopg2.Error as e:
        st.error(f"Error saving pre-assessment: {e}")
        if conn:
            conn.close()
        return None   
def section_1():
    st.header("üìã Section 1: Background Information & IQ Test")
    if 'step_1_completed' not in st.session_state:
        st.session_state.step_1_completed = False
    if 'step_2_completed' not in st.session_state:
        st.session_state.step_2_completed = False
    if not st.session_state.step_1_completed:
        with st.form("background_form"):
            name = st.text_input("What is your name?")
            present_domain = st.text_input("What domain are you currently working/studying in?")
            interested_field = st.text_input("What is your field of interest?")
            qualification = st.text_input("Your highest qualification?")
            years_experience = st.number_input("Years of experience:", min_value=0, step=1)
            formal_training = st.radio("Have you taken any formal training in this domain?", ["Yes", "No"])
            if st.form_submit_button("Next ‚Üí IQ Test"):
                if name and present_domain and interested_field:
                    st.session_state.basic_info = {
                        "name": name,
                        "present_domain": present_domain,
                        "interested_field": interested_field,
                        "qualification": qualification,
                        "years_experience": years_experience,
                        "formal_training": formal_training
                    }
                    st.session_state.step_1_completed = True
                    st.rerun()
                else:
                    st.error("Please complete all required fields.")
        return
    if not st.session_state.step_2_completed:
        st.subheader("üß† Quick IQ Assessment (3 Questions)")
        if 'iq_q_index' not in st.session_state:
            st.session_state.iq_q_index = 0
            st.session_state.iq_score = 0
            st.session_state.iq_questions = generate_questions(3, "General", "cognitive", "General", 3)
        if st.session_state.iq_q_index < 3:
            q = st.session_state.iq_questions[st.session_state.iq_q_index]
            st.write(f"**Q{st.session_state.iq_q_index + 1}:** {q['question_text']}")
            with st.form(f"iq_form_{st.session_state.iq_q_index}"):
                ans = st.radio("Choose your answer:", q['options'], index=None)
                if st.form_submit_button("Submit Answer"):
                    # The new generate_questions function will provide the full text answer
                    if ans == q['correct_answer']:
                        st.session_state.iq_score += 1
                        st.success("‚úÖ Correct!")
                    else:
                        st.warning(f"‚ùå Incorrect. The correct answer was: {q['correct_answer']}")
                    
                    time.sleep(1)
                    st.session_state.iq_q_index += 1
                    st.rerun()
            return
        else:
            st.session_state.step_2_completed = True
            st.success(f"üß† IQ Test Completed! Score: {st.session_state.iq_score}/3")
            st.rerun()
        return
    st.subheader("üéØ Select Your Course Domain")
    domain = st.selectbox("Which domain do you want to get assessed in?", AVAILABLE_COURSES)
    if st.button("Submit & Proceed"):
        info = st.session_state.basic_info
        knowledge_level = 2  # neutral
        cognitive_score = (st.session_state.iq_score / 3) * 100
        cognitive_iq = calculate_iq_score(st.session_state.iq_score, 3, 3)

        data = {
            'name': info['name'],
            'domain': domain,
            'present_domain': info['present_domain'],
            'interested_field': info['interested_field'],
            'qualification': info['qualification'],
            'years_experience': info['years_experience'],
            'preferred_difficulty': "Medium",
            'formal_training': info['formal_training'],
            'hours_per_day': 3,
            'weeks': 4,
            'knowledge_scale': knowledge_level,
            'cognitive_score': cognitive_score,
            'cognitive_iq': cognitive_iq,
            'domain_score': 0,
            'domain_iq': 0
        }
        roll_no = save_pre_assessment(data)
        if roll_no:
            st.session_state.roll_no = roll_no
            st.session_state.student_name = info['name']
            st.session_state.student_domain = domain
            st.success(f"‚úÖ Data saved! Your Roll No: {roll_no}")
            st.session_state.current_section = 2  
            st.rerun()
        else:
            st.error("Failed to save data.")
def get_quiz_model():
    genai.configure(api_key=GEMINI_API_KEY_QUIZ)
    return genai.GenerativeModel('gemini-2.0-flash')
def generate_questions(level, topic, section_type, domain, num_questions=1):
    """Generate quiz questions based on difficulty level and course domain."""
    quiz_model = get_quiz_model()

    question_type_prompt = ""
    if level <= 3:
        # Levels 1-3: Standard Multiple Choice Question
        question_type_prompt = f"""
        Generate {num_questions} multiple choice question(s) (MCQ).
        The JSON format must be:
        {{
            "question_text": "The question text...",
            "question_type": "mcq",
            "options": ["Option A", "Option B", "Option C", "Option D"],
            "correct_answer": "The full text of the correct option",
            "explanation": "A brief explanation of the answer."
        }}
        """
    elif level == 4:
        # Level 4: Multiple Select Question
        question_type_prompt = f"""
        Generate {num_questions} multiple-select question(s) where more than one option can be correct.
        The JSON format must be:
        {{
            "question_text": "The question text... (Select all that apply)",
            "question_type": "multi_select",
            "options": ["Option A", "Option B", "Option C", "Option D"],
            "correct_answers": ["Full text of correct option 1", "Full text of correct option 2"],
            "explanation": "A brief explanation of why these are correct."
        }}
        """
    else:  # level == 5
        # Level 5: Fill in the Blanks
        question_type_prompt = f"""
        Generate {num_questions} fill-in-the-blank question(s). Use '_____' to indicate the blank.
        The JSON format must be:
        {{
            "question_text": "The question text with a _____ in it.",
            "question_type": "fill_in_the_blank",
            "correct_answer": "The single word or short phrase that fills the blank",
            "explanation": "A brief explanation of the answer."
        }}
        """

    if section_type == "cognitive":
        prompt = f"""
        Generate {num_questions} cognitive reasoning question(s) related to {domain}.
        Focus on logical thinking and problem-solving.
        The difficulty level must be {level}/5.
        {question_type_prompt}
        Return the output as a valid JSON array.
        """
    else:  # "domain"
        prompt = f"""
        Generate {num_questions} technical knowledge question(s) about {domain}.
        Focus on core concepts and practical applications.
        The difficulty level must be {level}/5.
        {question_type_prompt}
        Return the output as a valid JSON array.
        All text must be in {st.session_state.selected_language}.
        """
    try:
        response = quiz_model.generate_content(prompt)
        # Clean the response to extract only the JSON part
        json_text = response.text[response.text.find('['):response.text.rfind(']') + 1]
        questions = json.loads(json_text)
        return questions
    except (json.JSONDecodeError, ValueError, IndexError) as e:
        st.error(f"Error parsing generated question. Please try again. Details: {e}")
        # Return a fallback question to avoid crashing
        return [{
            "question_text": "Which of the following is a primary color?",
            "question_type": "mcq",
            "options": ["Green", "Blue", "Orange", "Violet"],
            "correct_answer": "Blue",
            "explanation": "The primary colors are Red, Yellow, and Blue."
        }]
def check_answer(user_answer, correct_answer, question_type):
    """Check if the user's answer is correct for various question types."""
    if question_type == "mcq":
        return user_answer == correct_answer
    elif question_type == "multi_select":
        # Check if the set of user's answers matches the set of correct answers
        return isinstance(user_answer, list) and set(user_answer) == set(correct_answer)
    elif question_type == "fill_in_the_blank":
        # Case-insensitive and whitespace-trimmed comparison for text input
        return isinstance(user_answer, str) and user_answer.strip().lower() == correct_answer.strip().lower()
    return False
def section_2():
    st.header("üß† Section 2: Cognitive Assessment")

    if 'roll_no' not in st.session_state or not st.session_state.roll_no:
        st.error("Please complete Section 1 first.")
        return

    # Initialize session state for Section 2
    if 's2_initialized' not in st.session_state:
        st.session_state.s2_initialized = True
        st.session_state.s2_questions = []
        st.session_state.s2_current_q_idx = 0
        st.session_state.s2_score = 0
        st.session_state.s2_level = 3  # Start at level 3
        st.session_state.s2_completed = False

    if st.session_state.s2_completed:
        st.success("‚úÖ Cognitive Assessment Completed!")
        st.write(f"Final Score: {st.session_state.s2_score}/5")
        if st.button("Proceed to Section 3"):
            st.session_state.current_section = 3
            st.rerun()
        return

    st.write(f"**Question {st.session_state.s2_current_q_idx + 1} of 5**")
    st.write(f"Current Difficulty Level: {st.session_state.s2_level}/5")
    st.progress((st.session_state.s2_current_q_idx) / 5)

    # Generate a question if we don't have one for the current index
    if len(st.session_state.s2_questions) <= st.session_state.s2_current_q_idx:
        with st.spinner("Generating question..."):
            new_questions = generate_questions(
                level=st.session_state.s2_level,
                topic=st.session_state.student_domain,
                section_type="cognitive",
                domain=st.session_state.student_domain,
                num_questions=1
            )
            if new_questions:
                st.session_state.s2_questions.extend(new_questions)
                st.rerun()
            else:
                st.error("Failed to generate a question. Please refresh.")
                return

    # Display the current question if available
    if len(st.session_state.s2_questions) > st.session_state.s2_current_q_idx:
        q = st.session_state.s2_questions[st.session_state.s2_current_q_idx]
        
        # --- START OF NEW VALIDATION LOGIC ---
        is_valid = True
        q_type = q.get("question_type")
        if not all(k in q for k in ["question_text"]):
            is_valid = False
        if q_type in ["mcq", "multi_select"] and (not isinstance(q.get("options"), list) or not q.get("options")):
            is_valid = False
        if q_type == "fill_in_the_blank" and not q.get("correct_answer"):
            is_valid = False

        if not is_valid:
            st.warning("üîÑ The generated question was incomplete. Automatically fetching a new one...")
            # Remove the invalid question and rerun to generate a new one
            st.session_state.s2_questions.pop(st.session_state.s2_current_q_idx)
            time.sleep(1) 
            st.rerun()
            return
        # --- END OF NEW VALIDATION LOGIC ---

        with st.form(f"s2_form_{st.session_state.s2_current_q_idx}"):
            st.write(f"**{q['question_text']}**")
            user_answer = None
            if q_type == "mcq":
                user_answer = st.radio("Select your answer:", q['options'], index=None)
            elif q_type == "multi_select":
                user_answer = st.multiselect("Select all correct answers:", q['options'])
            elif q_type == "fill_in_the_blank":
                user_answer = st.text_input("Fill in the blank:")

            if st.form_submit_button("Submit Answer"):
                correct_answer = q.get('correct_answer') or q.get('correct_answers')
                is_correct = check_answer(user_answer, correct_answer, q_type)

                if is_correct:
                    st.session_state.s2_score += 1
                    st.success("‚úÖ Correct!")
                    if st.session_state.s2_level < 5:
                        st.session_state.s2_level += 1
                else:
                    st.error(f"‚ùå Incorrect. The correct answer is: {correct_answer}")
                    if st.session_state.s2_level > 1:
                        st.session_state.s2_level -= 1

                st.session_state.s2_current_q_idx += 1

                if st.session_state.s2_current_q_idx >= 5:
                    st.session_state.s2_completed = True
                    cognitive_score = (st.session_state.s2_score / 5) * 100
                    cognitive_iq = calculate_iq_score(st.session_state.s2_score, 5, st.session_state.s2_level)
                    update_cognitive_scores(st.session_state.roll_no, cognitive_score, cognitive_iq)

                time.sleep(1)
                st.rerun()
def update_cognitive_scores(roll_no, cognitive_score, cognitive_iq):
    """Update cognitive score and IQ in database"""
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE pre_assessment 
            SET cognitive_score = %s, cognitive_iq = %s 
            WHERE roll_no = %s
        """, (cognitive_score, cognitive_iq, roll_no))
        conn.commit()
        cursor.close()
        conn.close()
        analyze_and_update_performance(roll_no)
        return True      
    except psycopg2.Error as e:
        st.error(f"Error updating cognitive scores: {e}")
        if conn:
            conn.close()
        return False
def analyze_and_update_performance(roll_no):
    """Analyze student performance and update topics_excellented"""
    conn = get_db_connection()
    if conn is None:
        return False   
    try:
        cursor = conn.cursor(cursor_factory=RealDictCursor)       
        cursor.execute("""
            SELECT domain, cognitive_score, domain_score, viva_score 
            FROM pre_assessment WHERE roll_no = %s
        """, (roll_no,))
        student = cursor.fetchone()        
        if not student:
            return False
        cursor.execute("""
            SELECT week_no, week_quiz_score, strong_areas, weak_areas
            FROM week_quiz WHERE roll_no = %s ORDER BY week_no
        """, (roll_no,))
        weekly_data = cursor.fetchall()
        excellented_topics = []
        if student['cognitive_score'] >= 80:
            excellented_topics.append("Logical Reasoning")
            excellented_topics.append("Problem Solving")
        if student['domain_score'] >= 80:
            domain = student['domain']
            if domain == "Python":
                excellented_topics.extend(["Python Fundamentals", "Programming Logic"])
            elif domain == "Data Science":
                excellented_topics.extend(["Data Analysis", "Statistical Concepts"])
            elif domain == "Machine Learning":
                excellented_topics.extend(["ML Algorithms", "Model Training"])
        if student['viva_score'] >= 80:
            excellented_topics.append("Communication Skills")
            excellented_topics.append("Technical Explanation")
        for week in weekly_data:
            if week['week_quiz_score'] >= 80:
                if week['strong_areas'] and week['strong_areas'] != 'None identified':
                    excellented_topics.append(f"Week {week['week_no']}: {week['strong_areas']}")
        avg_score = (student['cognitive_score'] + student['domain_score'] + student['viva_score']) / 3        
        if avg_score >= 80:
            outcome = "Excellent performance - Ready for advanced topics"
            progress = "Outstanding learner with strong grasp of concepts"
        elif avg_score >= 70:
            outcome = "Good performance - Solid foundation established"  
            progress = "Good learner with areas for improvement identified"
        elif avg_score >= 60:
            outcome = "Satisfactory performance - Basic concepts understood"
            progress = "Average learner requiring additional practice"
        else:
            outcome = "Needs improvement - Requires additional support"
            progress = "Struggling learner needing focused remediation"
        topics_str = ", ".join(set(excellented_topics)) if excellented_topics else "No topics excellented yet"        
        cursor.execute("""
            UPDATE overall_performance 
            SET topics_excellented = %s, outcome_of_course = %s, student_progress = %s,
                last_updated = CURRENT_TIMESTAMP
            WHERE roll_no = %s
        """, (topics_str, outcome, progress, roll_no))       
        conn.commit()
        cursor.close()
        conn.close()
        return True        
    except psycopg2.Error as e:
        st.error(f"Error updating performance: {e}")
        if conn:
            conn.close()
        return False
def update_domain_scores(roll_no, domain_score, domain_iq):
    """Update domain score and IQ in database"""
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE pre_assessment 
            SET domain_score = %s, domain_iq = %s 
            WHERE roll_no = %s
        """, (domain_score, domain_iq, roll_no))
        conn.commit()
        cursor.close()
        conn.close()
        analyze_and_update_performance(roll_no)
        return True        
    except psycopg2.Error as e:
        st.error(f"Error updating domain scores: {e}")
        if conn:
            conn.close()
        return False
def update_viva_score(roll_no, viva_score, viva_response):
    """Update viva score and response"""
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE pre_assessment 
            SET viva_score = %s, viva_response = %s 
            WHERE roll_no = %s
        """, (viva_score, viva_response, roll_no))
        conn.commit()
        cursor.close()
        conn.close()
        analyze_and_update_performance(roll_no)
        return True        
    except psycopg2.Error as e:
        st.error(f"Error updating viva score: {e}")
        if conn:
            conn.close()
        return False
def calculate_iq_score(correct_answers, total_questions, difficulty_level):
    """Calculate IQ score"""
    if total_questions == 0:
        return 100   
    accuracy = correct_answers / total_questions
    base_iq = 100
    adjusted_score = base_iq + (accuracy - 0.5) * 40
    return max(70, min(160, int(adjusted_score)))
def section_3():
    st.header("üìö Section 3: Domain Knowledge Assessment")

    if not st.session_state.roll_no:
        st.error("Please complete previous sections first.")
        return

    # Initialize session state for Section 3
    if 's3_initialized' not in st.session_state:
        st.session_state.s3_initialized = True
        st.session_state.s3_questions = []
        st.session_state.s3_current_q_idx = 0
        st.session_state.s3_score = 0
        st.session_state.s3_level = 3  # Start at level 3
        st.session_state.s3_completed = False

    if st.session_state.s3_completed:
        st.success("‚úÖ Domain Knowledge Assessment Completed!")
        st.write(f"Final Score: {st.session_state.s3_score}/5")
        if st.button("Proceed to Section 4"):
            st.session_state.current_section = 4
            st.rerun()
        return

    st.write(f"**Question {st.session_state.s3_current_q_idx + 1} of 5**")
    st.write(f"Current Difficulty Level: {st.session_state.s3_level}/5")
    st.progress((st.session_state.s3_current_q_idx) / 5)

    # Generate a question if we don't have one for the current index
    if len(st.session_state.s3_questions) <= st.session_state.s3_current_q_idx:
        with st.spinner("Generating question..."):
            new_questions = generate_questions(
                level=st.session_state.s3_level,
                topic=st.session_state.student_domain,
                section_type="domain",
                domain=st.session_state.student_domain,
                num_questions=1
            )
            if new_questions:
                st.session_state.s3_questions.extend(new_questions)
                st.rerun()
            else:
                st.error("Failed to generate a question. Please refresh.")
                return

    # Display the current question
    if len(st.session_state.s3_questions) > st.session_state.s3_current_q_idx:
        q = st.session_state.s3_questions[st.session_state.s3_current_q_idx]

        # --- START OF NEW VALIDATION LOGIC ---
        is_valid = True
        q_type = q.get("question_type")
        if not all(k in q for k in ["question_text"]):
            is_valid = False
        if q_type in ["mcq", "multi_select"] and (not isinstance(q.get("options"), list) or not q.get("options")):
            is_valid = False
        if q_type == "fill_in_the_blank" and not q.get("correct_answer"):
            is_valid = False

        if not is_valid:
            st.warning("üîÑ The generated question was incomplete. Automatically fetching a new one...")
            # Remove the invalid question and rerun to generate a new one
            st.session_state.s3_questions.pop(st.session_state.s3_current_q_idx)
            time.sleep(1)
            st.rerun()
            return
        # --- END OF NEW VALIDATION LOGIC ---

        with st.form(f"s3_form_{st.session_state.s3_current_q_idx}"):
            st.write(f"**{q['question_text']}**")
            user_answer = None
            if q_type == "mcq":
                user_answer = st.radio("Select your answer:", q['options'], index=None)
            elif q_type == "multi_select":
                user_answer = st.multiselect("Select all correct answers:", q['options'])
            elif q_type == "fill_in_the_blank":
                user_answer = st.text_input("Fill in the blank:")

            if st.form_submit_button("Submit Answer"):
                correct_answer = q.get('correct_answer') or q.get('correct_answers')
                is_correct = check_answer(user_answer, correct_answer, q_type)

                if is_correct:
                    st.session_state.s3_score += 1
                    st.success("‚úÖ Correct!")
                    if st.session_state.s3_level < 5:
                        st.session_state.s3_level += 1
                else:
                    st.error(f"‚ùå Incorrect. The correct answer is: {correct_answer}")
                    if st.session_state.s3_level > 1:
                        st.session_state.s3_level -= 1

                st.session_state.s3_current_q_idx += 1

                if st.session_state.s3_current_q_idx >= 5:
                    st.session_state.s3_completed = True
                    domain_score = (st.session_state.s3_score / 5) * 100
                    domain_iq = calculate_iq_score(st.session_state.s3_score, 5, st.session_state.s3_level)
                    update_domain_scores(st.session_state.roll_no, domain_score, domain_iq)

                time.sleep(1)
                st.rerun()
def section_4():
    st.header("üé§ Section 4: Viva Voce")   
    if not st.session_state.roll_no:
        st.error("Please complete previous sections first")
        return   
    if 'viva_completed' not in st.session_state:
        st.session_state.viva_completed = False    
    if st.session_state.viva_completed:
        st.success("‚úÖ Viva Voce Completed!")
        if st.button("Proceed to Section 5"):
            st.session_state.current_section = 5
            st.rerun()
        return
    student_data = get_student_data(st.session_state.roll_no)
    if not student_data:
        st.error("Failed to retrieve student data")
        return
    if 'viva_question' not in st.session_state:
        with st.spinner("Generating viva question..."):
            viva_data = generate_viva_question(
                student_data['domain'],
                student_data['cognitive_score'],
                student_data['domain_score']
            )
            st.session_state.viva_question = viva_data   
    st.write("**Viva Question:**")
    st.write(st.session_state.viva_question['question'])   
    st.write("**Expected Points to Cover:**")
    for point in st.session_state.viva_question['expected_points']:
        st.write(f"‚Ä¢ {point}")    
    with st.form("viva_form"):
        viva_response = st.text_area("Your Answer:", height=200, placeholder="Provide your detailed answer here...")       
        if st.form_submit_button("Submit Viva Answer"):
            if viva_response.strip():
                viva_score = min(100, len(viva_response.split()) * 2)  # Basic scoring
                update_viva_score(st.session_state.roll_no, viva_score, viva_response)                
                st.success(f"‚úÖ Viva completed! Score: {viva_score}/100")
                st.session_state.viva_completed = True
                st.rerun()
            else:
                st.error("Please provide an answer")
def generate_viva_question(domain, cognitive_score, domain_score):
    """Generate a viva question based on domain and scores"""
    viva_model = get_viva_model()   
    difficulty = "basic" if (cognitive_score + domain_score) / 2 < 60 else "intermediate" if (cognitive_score + domain_score) / 2 < 80 else "advanced"   
    prompt = f"""Generate 1 viva voce question for {domain} at {difficulty} level.  
    Format as JSON:
    {{
        "question": "The viva question about {domain}",
        "expected_points": ["point1", "point2", "point3"],
        "evaluation_criteria": "How to evaluate the answer"
    }}   
    Make it open-ended and suitable for oral examination focusing on {domain}."""   
    try:
        response = viva_model.generate_content(prompt)
        json_start = response.text.find('{')
        json_end = response.text.rfind('}') + 1
        json_data = response.text[json_start:json_end]
        return json.loads(json_data)
    except Exception as e:
        st.error(f"Error generating viva question: {e}")
        return {
            "question": f"Explain the key concepts and applications of {domain} in real-world scenarios.",
            "expected_points": ["Fundamental concepts", "Practical applications", "Current trends"],
            "evaluation_criteria": "Clarity of explanation, depth of knowledge, practical understanding"
        }
def get_student_data(roll_no):
    """Get complete student data"""
    conn = get_db_connection()
    if conn is None:
        return None
    try:
        cursor = conn.cursor(cursor_factory=RealDictCursor)        
        query = """
        SELECT pa.*, op.topics_excellented, op.outcome_of_course, op.student_progress
        FROM pre_assessment pa
        LEFT JOIN overall_performance op ON pa.roll_no = op.roll_no
        WHERE pa.roll_no = %s
        """        
        cursor.execute(query, (roll_no,))
        student_data = cursor.fetchone()        
        if student_data:
            cursor.execute("SELECT * FROM week_quiz WHERE roll_no = %s ORDER BY week_no", (roll_no,))
            week_data = cursor.fetchall()           
            cursor.execute("SELECT * FROM course_content WHERE roll_no = %s ORDER BY week_no", (roll_no,))
            course_data = cursor.fetchall()            
            result = dict(student_data)
            result['week_quizzes'] = [dict(row) for row in week_data]
            result['course_contents'] = [dict(row) for row in course_data]
        else:
            result = None        
        cursor.close()
        conn.close()
        return result
    except psycopg2.Error as e:
        st.error(f"Error retrieving student data: {e}")
        if conn:
            conn.close()
        return None
def section_5():
    st.header("‚öôÔ∏è Section 5: Course Configuration")   
    if not st.session_state.roll_no:
        st.error("Please complete previous sections first")
        return    
    if 'course_configured' not in st.session_state:
        st.session_state.course_configured = False    
    if st.session_state.course_configured:
        st.success("‚úÖ Course Configuration Completed!")
        if st.button("Proceed to Section 6"):
            st.session_state.current_section = 6
            st.rerun()
        return    
    st.write("Configure your learning schedule:")    
    with st.form("config_form"):
        hours_per_day = st.slider("Hours per day:", 1, 8, 3)
        weeks = st.slider("Number of weeks:", 2, 12, 4)        
        if st.form_submit_button("Configure Course"):
            if update_course_config(st.session_state.roll_no, hours_per_day, weeks):
                st.session_state.hours_per_day = hours_per_day
                st.session_state.weeks = weeks
                st.session_state.course_configured = True
                st.success("‚úÖ Course configured successfully!")
                st.rerun()
            else:
                st.error("Failed to configure course")
def update_course_config(roll_no, hours_per_day, weeks):
    """Update course configuration"""
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE pre_assessment 
            SET hours_per_day = %s, weeks = %s, course_configured = TRUE
            WHERE roll_no = %s
        """, (hours_per_day, weeks, roll_no))
        conn.commit()
        cursor.close()
        conn.close()
        return True
    except psycopg2.Error as e:
        st.error(f"Error updating course config: {e}")
        if conn:
            conn.close()
        return False
def section_6():
    st.header("üìñ Section 6: Course Learning")
    if not st.session_state.roll_no:
        st.error("Please complete previous sections first")
        return
    student_data = get_student_data(st.session_state.roll_no)
    if not student_data:
        st.error("Failed to retrieve student data")
        return
    current_week = student_data.get('current_week_no', 1)
    total_weeks = student_data.get('weeks', 4)
    st.subheader(f"üìÖ Week {current_week} of {total_weeks}")
    topics = []
    if f"week_{current_week}_topics" not in st.session_state:
        content = None
        for row in student_data.get('course_contents', []):
            if row['week_no'] == current_week:
                content = row['course_content']
                break
        if not content:
            with st.spinner("Generating weekly content..."):
                previous_analysis = None
                if current_week > 1:
                    for q in student_data.get('week_quizzes', []):
                        if q['week_no'] == current_week - 1:
                            previous_analysis = q.get('analysis', '')
                            break
                content = generate_course_content(
                    student_data.get("domain"),
                    current_week,
                    student_data.get("hours_per_day", 3),
                    previous_analysis
                )
                save_course_content(st.session_state.roll_no, current_week, content)
        topic_blocks = re.findall(r"(Topic\s*\d+:\s*.*?)(?=Topic\s*\d+:|$)", content, re.DOTALL)
        topics = [block.strip() for block in topic_blocks]
        st.session_state[f"week_{current_week}_topics"] = topics
    else:
        topics = st.session_state[f"week_{current_week}_topics"]
    st.markdown("## üìö Topics & Mini Quizzes")
    for idx, topic_content in enumerate(topics, start=1):
        topic_name_match = re.match(r"Topic\s*\d+:\s*(.*)", topic_content.split('\n')[0])
        topic_name = topic_name_match.group(1).strip() if topic_name_match else f"Topic {idx}"
        st.markdown(f"### üìù Topic {idx}: {topic_name}")
        st.markdown(topic_content)
        quiz_key = f"mini_quiz_{current_week}_{idx}"
        if f"{quiz_key}_answered" not in st.session_state:
            mini_quiz = generate_mini_quiz(topic_name, student_data["domain"])
            if mini_quiz:
                st.write(mini_quiz["question_text"])
                answer = st.radio("Choose an answer:", mini_quiz["options"], key=f"{quiz_key}_options")
                if st.button("Submit Mini Quiz", key=f"{quiz_key}_submit"):
                    is_correct = check_answer(answer, mini_quiz["correct_answer"], "mcq")
                    score = 1 if is_correct else 0
                    save_mini_quiz_result(
                        st.session_state.roll_no,
                        current_week,
                        idx,
                        topic_name,
                        score
                    )
                    st.session_state[f"{quiz_key}_answered"] = True
                    st.success(f"{'‚úÖ Correct!' if is_correct else '‚ùå Incorrect.'} Saved for {topic_name}")
                    st.rerun()
            else:
                st.warning("Failed to generate mini quiz.")
        else:
            st.info(f"Mini Quiz for {topic_name} already submitted.")
    st.markdown("---")
    st.subheader(f"üìó Week {current_week} Final Quiz")
    quiz_taken = any(q['week_no'] == current_week for q in student_data.get('week_quizzes', []))
    if not quiz_taken:
        if 'weekly_quiz' not in st.session_state or st.session_state.get('current_quiz_week') != current_week:
            st.session_state.weekly_quiz = []
            st.session_state.weekly_quiz_idx = 0
            st.session_state.weekly_quiz_score = 0
            st.session_state.current_quiz_week = current_week
        if not st.session_state.weekly_quiz:
            with st.spinner("Generating weekly quiz..."):
                prev_score = None
                if current_week > 1:
                    for q in student_data.get('week_quizzes', []):
                        if q['week_no'] == current_week - 1:
                            prev_score = q.get('week_quiz_score', 0)
                            break
                quiz_questions = generate_weekly_quiz(
                    st.session_state.student_domain,
                    current_week,
                    prev_score
                )
                st.session_state.weekly_quiz = quiz_questions
        if st.session_state.weekly_quiz:
            current_q_idx = st.session_state.weekly_quiz_idx
            if current_q_idx < len(st.session_state.weekly_quiz):
                question = st.session_state.weekly_quiz[current_q_idx]
                st.write(f"**Question {current_q_idx + 1}:**")
                st.write(question.get('question_text', ''))
                options = question.get('options', [])
                user_answer = st.radio("Choose your answer:", options, key=f"weekly_q{current_week}_{current_q_idx}")
                if st.button("Submit Answer", key=f"weekly_submit{current_week}_{current_q_idx}"):
                    correct = check_answer(user_answer, question.get('correct_answer'), question.get('question_type'))
                    if correct:
                        st.session_state.weekly_quiz_score += 1
                        st.success("Correct!")
                    else:
                        st.error(f"Incorrect. The correct answer is: {question.get('correct_answer')}")

                    st.session_state.weekly_quiz_idx += 1
                    st.rerun()
            else:
                total_q = len(st.session_state.weekly_quiz)
                quiz_score = (st.session_state.weekly_quiz_score / total_q) * 100
                quiz_iq = calculate_iq_score(st.session_state.weekly_quiz_score, total_q, 3)

                st.success(f"‚úÖ Week {current_week} Quiz Complete!")
                st.write(f"Score: {st.session_state.weekly_quiz_score}/{total_q} ({quiz_score:.1f}%)")
                if quiz_score >= 80:
                    strong_areas = f"Week {current_week} topics"
                    weak_areas = "None identified"
                    analysis = "Excellent performance"
                elif quiz_score >= 60:
                    strong_areas = f"Most Week {current_week} topics"
                    weak_areas = "Minor gaps identified"
                    analysis = "Good performance with room for improvement"
                else:
                    strong_areas = "Basic concepts"
                    weak_areas = f"Week {current_week} advanced topics"
                    analysis = "Needs more practice"
                quiz_data = {
                    'score': quiz_score,
                    'iq': quiz_iq,
                    'strong_areas': strong_areas,
                    'weak_areas': weak_areas,
                    'analysis': analysis
                }
                if save_week_quiz(st.session_state.roll_no, current_week, quiz_data):
                    st.write(f"**Analysis:** {analysis}")
                    if current_week < total_weeks:
                        if st.button("Proceed to Next Week"):
                            next_week = current_week + 1
                            if update_current_week(st.session_state.roll_no, next_week):
                                for key in ['weekly_quiz', 'weekly_quiz_idx', 'weekly_quiz_score', 'current_quiz_week']:
                                    if key in st.session_state:
                                        del st.session_state[key]
                                st.success(f"Moving to Week {next_week}")
                                st.rerun()
                            else:
                                st.error("Failed to update week progress")
                    else:
                        st.success("üéâ Course Complete!")
                        if st.button("View Final Analysis"):
                            st.session_state.current_section = 7
                            st.rerun()
                else:
                    st.error("Failed to save quiz results")
    else:
        st.info("‚úÖ Weekly quiz already completed.")
        for quiz in student_data.get('week_quizzes', []):
            if quiz['week_no'] == current_week:
                st.write(f"**Score:** {quiz.get('week_quiz_score', 0):.1f}%")
                st.write(f"**Analysis:** {quiz.get('analysis', 'N/A')}")
                break
        if current_week < total_weeks:
            if st.button("Continue to Next Week"):
                next_week = current_week + 1
                if update_current_week(st.session_state.roll_no, next_week):
                    for key in ['weekly_quiz', 'weekly_quiz_idx', 'weekly_quiz_score', 'current_quiz_week']:
                        if key in st.session_state:
                            del st.session_state[key]
                    st.rerun()
                else:
                    st.error("Failed to update week progress")
        else:
            if st.button("View Final Analysis"):
                st.session_state.current_section = 7
                st.rerun()
def update_current_week(roll_no, week_no):
    """Update current week number"""
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE pre_assessment 
            SET current_week_no = %s 
            WHERE roll_no = %s
        """, (week_no, roll_no))
        conn.commit()
        cursor.close()
        conn.close()
        return True
    except psycopg2.Error as e:
        st.error(f"Error updating current week: {e}")
        if conn:
            conn.close()
        return False
def save_week_quiz(roll_no, week_no, quiz_data):
    """Save week quiz results and update overall performance"""
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()       
        cursor.execute("""
            INSERT INTO week_quiz (roll_no, week_no, week_quiz_score, week_quiz_iq, strong_areas, weak_areas, analysis)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
            ON CONFLICT (roll_no, week_no) 
            DO UPDATE SET 
                week_quiz_score = EXCLUDED.week_quiz_score,
                week_quiz_iq = EXCLUDED.week_quiz_iq,
                strong_areas = EXCLUDED.strong_areas,
                weak_areas = EXCLUDED.weak_areas,
                analysis = EXCLUDED.analysis,
                date = CURRENT_TIMESTAMP
        """, (
            roll_no, week_no, quiz_data.get('score', 0), quiz_data.get('iq', 0),
            quiz_data.get('strong_areas', ''), quiz_data.get('weak_areas', ''), 
            quiz_data.get('analysis', '')
        ))       
        conn.commit()
        cursor.close()
        conn.close()
        analyze_and_update_performance(roll_no)
        return True       
    except psycopg2.Error as e:
        st.error(f"Error saving week quiz: {e}")
        if conn:
            conn.close()
        return False
def generate_weekly_quiz(domain, week_number, previous_score=None):
    """Generate weekly quiz based on domain and performance"""
    quiz_model = get_quiz_model()    
    difficulty_adj = ""
    if previous_score is not None:
        if previous_score < 60:
            difficulty_adj = "Make questions easier to build confidence."
        elif previous_score > 80:
            difficulty_adj = "Make questions more challenging."    
    prompt = f"""Generate 3 quiz questions for Week {week_number} of {domain} course.
    {difficulty_adj}   
    Focus on Week {week_number} topics of {domain}.
    Format as JSON array with question_text, question_type (mcq), options, correct_answer, explanation fields.
    Make questions practical and applicable to {domain}."""   
    try:
        response = quiz_model.generate_content(prompt)
        json_start = response.text.find('[')
        json_end = response.text.rfind(']') + 1
        json_data = response.text[json_start:json_end]
        return json.loads(json_data)
    except Exception as e:
        st.error(f"Error generating weekly quiz: {e}")
        return []
def generate_course_content(domain, week_no, hours_per_day, previous_performance=None):
    model = get_quiz_model()  
    prompt = f"""
Generate course content for **Week {week_no}** of a **{domain}** course.

üïí The student will study **{hours_per_day} hours per day for 7 days**.

üß© Structure the content as follows:
1. **List 3 clearly separated topics** using the format:
   - `Topic 1: <Topic Title>`
   - `Topic 2: <Topic Title>`
   - `Topic 3: <Topic Title>`
2. After each topic title, provide:
   - a 2‚Äì3 paragraph explanation or lesson content
   - practical examples or explanations

‚ö†Ô∏è Important formatting rules:
- Each topic should start with a **header line**: `Topic X: <title>`
- Separate topics with one blank line
- Do **not** include daily schedules, references, or anything else ‚Äî only structured topics and content

Example:
Topic 1: Data Types in Python
[explanation]

Topic 2: Conditional Statements
[explanation]

Topic 3: Loops
[explanation]
"""
    if previous_performance:
        prompt += f"\n\nüìà Adjust content difficulty or focus based on the following performance feedback:\n{previous_performance}"
    try:
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        st.error(f"Error generating course content: {e}")
        return f"Week {week_no} content for {domain} could not be generated."
def extract_topics_from_content(course_content):
    topic_section = re.search(r"Topics to Cover This Week(.*?)(?:\n\d+\.\s+Daily Study Plan|\n### Daily Study Plan)", course_content, re.DOTALL)
    if not topic_section:
        return []
    lines = topic_section.group(1).splitlines()
    topics = [re.sub(r"^\d+\.\s*", "", line.strip()) for line in lines if line.strip()]
    return [t for t in topics if len(t.split()) >= 2] 
def save_course_content(roll_no, week_no, content):
    """Save course content to database"""
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO course_content (roll_no, week_no, course_content)
            VALUES (%s, %s, %s)
            ON CONFLICT (roll_no, week_no) 
            DO UPDATE SET course_content = EXCLUDED.course_content
        """, (roll_no, week_no, content))
        conn.commit()
        cursor.close()
        conn.close()
        return True
    except psycopg2.Error as e:
        st.error(f"Error saving course content: {e}")
        if conn:
            conn.close()
        return False
def section_7():
    st.header("üìä Section 7: Performance Analysis")  
    if not st.session_state.roll_no:
        st.error("Please complete previous sections first")
        return   
    student_data = get_student_data(st.session_state.roll_no)
    if not student_data:
        st.error("Failed to retrieve student data")
        return
    analyze_and_update_performance(st.session_state.roll_no)
    student_data = get_student_data(st.session_state.roll_no)
    st.markdown("### üéØ Your Learning Journey Dashboard")
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric(
            label="üß† Cognitive Score",
            value=f"{student_data.get('cognitive_score', 0):.1f}%",
            delta=f"IQ: {student_data.get('cognitive_iq', 100)}"
        )  
    with col2:
        st.metric(
            label="üìö Domain Score", 
            value=f"{student_data.get('domain_score', 0):.1f}%",
            delta=f"IQ: {student_data.get('domain_iq', 100)}"
        )   
    with col3:
        st.metric(
            label="üé§ Viva Score",
            value=f"{student_data.get('viva_score', 0)}/100",
            delta="Oral Assessment"
        )   
    with col4:
        overall_score = (student_data.get('cognitive_score', 0) + 
                        student_data.get('domain_score', 0) + 
                        student_data.get('viva_score', 0)) / 3
        st.metric(
            label="üåü Overall Score",
            value=f"{overall_score:.1f}%",
            delta="Combined Performance"
        )
    st.markdown("### üèÜ Topics You've Mastered")
    topics_excellented = student_data.get('topics_excellented', 'No topics excellented yet')    
    if topics_excellented and topics_excellented != 'No topics excellented yet':
        topics_list = [topic.strip() for topic in topics_excellented.split(',')]
        for topic in topics_list:
            st.success(f"‚úÖ {topic}")
    else:
        st.info("Complete more assessments to see your mastered topics!")
    st.markdown("### üìà Course Outcome")
    outcome = student_data.get('outcome_of_course', 'Course in progress')
    st.write(f"**Status:** {outcome}")   
    progress_desc = student_data.get('student_progress', 'Assessment in progress')
    st.write(f"**Progress:** {progress_desc}")
    st.markdown("### üìà Weekly Progress") 
    if student_data.get('week_quizzes'):
        import pandas as pd       
        quiz_data = []
        for quiz in student_data['week_quizzes']:
            quiz_data.append({
                'Week': f"Week {quiz['week_no']}",
                'Score': quiz['week_quiz_score'],
                'IQ': quiz['week_quiz_iq']
            })      
        if quiz_data:
            df = pd.DataFrame(quiz_data)
            st.line_chart(df.set_index('Week'))
    st.markdown("### üí° Performance Insights")
    col1, col2 = st.columns(2)   
    with col1:
        st.markdown("#### üéØ Strengths")
        if student_data.get('cognitive_score', 0) >= 70:
            st.success("‚úÖ Strong cognitive abilities")
        if student_data.get('domain_score', 0) >= 70:
            st.success("‚úÖ Good domain knowledge")
        if student_data.get('viva_score', 0) >= 70:
            st.success("‚úÖ Excellent communication skills")   
    with col2:
        st.markdown("#### üîß Areas for Improvement")
        if student_data.get('cognitive_score', 0) < 70:
            st.warning("‚ö†Ô∏è Focus on logical reasoning")
        if student_data.get('domain_score', 0) < 70:
            st.warning("‚ö†Ô∏è Study core concepts more")
        if student_data.get('viva_score', 0) < 70:
            st.warning("‚ö†Ô∏è Practice verbal explanations")
    st.markdown("### üèÜ Course Status")    
    current_week = student_data.get('current_week_no', 1)
    total_weeks = student_data.get('weeks', 4)
    progress = (current_week / total_weeks) * 100    
    st.progress(progress/100)
    st.write(f"Course Progress: {progress:.1f}% ({current_week}/{total_weeks} weeks)")
    st.markdown("### üéØ Personalized Recommendations")    
    recommendations = []    
    if overall_score >= 80:
        recommendations.append("üåü Excellent performance! Consider advanced topics.")
    elif overall_score >= 60:
        recommendations.append("üëç Good progress! Focus on weak areas.")
    else:
        recommendations.append("üìö Review fundamentals and practice more.")   
    if student_data.get('cognitive_score', 0) > student_data.get('domain_score', 0):
        recommendations.append("üí° Strong analytical skills - dive deeper into technical concepts.")
    else:
        recommendations.append("üß† Good domain knowledge - work on problem-solving skills.")   
    for rec in recommendations:
        st.info(rec)
    if st.button("üîÑ Refresh Performance Analysis"):
        if analyze_and_update_performance(st.session_state.roll_no):
            st.success("Performance analysis updated!")
            st.rerun()
        else:
            st.error("Failed to update performance analysis")
    if st.button("üìÑ Download Performance Report"):
        st.success("Report generated! (Feature would download PDF in full implementation)")
    st.markdown("### üîÑ Preparing data for final course generation...")
    with st.spinner("Running background agents..."):
        run_agent_pre_assessment(st.session_state.roll_no)
        run_agent_mini_quiz(st.session_state.roll_no)
        run_agent_weekly_quiz(st.session_state.roll_no)
        run_agent_overall_performance(st.session_state.roll_no)
        run_agent_course_fetch(st.session_state.roll_no)
        run_agent_trend_fetch(st.session_state.roll_no)
    st.success("Agent processing complete! You can now go to Section 8 to generate your course.")
def create_login_table():
    """Create login table"""
    conn = get_db_connection()
    if conn is None:
        return False
    try:
        cursor = conn.cursor()
        create_login_query = """
        CREATE TABLE IF NOT EXISTS user_login (
            id SERIAL PRIMARY KEY,
            email VARCHAR(255) UNIQUE NOT NULL,
            password VARCHAR(255) NOT NULL,
            total_logins INTEGER DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            last_login TIMESTAMP
        );"""        
        cursor.execute(create_login_query)
        conn.commit()
        cursor.close()
        conn.close()
        return True
    except psycopg2.Error as e:
        st.error(f"Error creating login table: {e}")
        if conn:
            conn.close()
        return False
def login_user(email, password):
    """Login user"""
    conn = get_db_connection()
    if conn is None:
        return False, "Database connection error"    
    try:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT email, password FROM user_login 
            WHERE email = %s AND password = %s
        """, (email, password))       
        user = cursor.fetchone()
        if user:
            cursor.execute("""
                UPDATE user_login 
                SET total_logins = total_logins + 1, last_login = CURRENT_TIMESTAMP 
                WHERE email = %s
            """, (email,))
            conn.commit()
            cursor.close()
            conn.close()
            return True, "Login successful"
        else:
            cursor.close()
            conn.close()
            return False, "Invalid email or password"
    except psycopg2.Error as e:
        if conn:
            conn.close()
        return False, f"Login error: {e}"
def generate_video_script_from_content(file_summary, file_name):
    prompt = f"""
üé¨ You are a creative educational video scriptwriter.

üìÅ File: {file_name}

üìù Summary of the file content:
{file_summary}

---

üéØ TASK:
1. Generate a video prompt and educational script based entirely on the content summarized above.
2. Explain the key concepts, structure, or story as if presenting in a short YouTube explainer video.
3. The style should be **friendly, clear, and slightly engaging**, suitable for students or general learners.
4. Include relevant analogies or simple examples to help understanding.
5. Make sure the script reflects what the uploaded file is about.

---

‚úÖ OUTPUT FORMAT:

## üé• Video Prompt:
<Brief idea of visuals, style, tone, animation (if needed)>

## üìù Script:
<Full video script - 2 to 3 minutes long>
"""
    model = get_super_agent_model()
    try:
        response = model.generate_content(prompt)
        return response.text.strip()
    except Exception as e:
        return f"Error generating video script: {e}"
def login_page():
    """Display login page"""
    st.title("üîê Login to Adaptive Quiz System")   
    tab1, tab2 = st.tabs(["Login", "Register"])   
    with tab1:
        st.header("Login")
        with st.form("login_form"):
            email = st.text_input("Email:")
            password = st.text_input("Password:", type="password")           
            if st.form_submit_button("Login"):
                if email and password:
                    success, message = login_user(email, password)
                    if success:
                        st.session_state.logged_in = True
                        st.session_state.user_email = email
                        st.success(message)
                        st.rerun()
                    else:
                        st.error(message)
                else:
                    st.error("Please fill in all fields")   
    with tab2:
        st.header("Register New Account")
        with st.form("register_form"):
            reg_email = st.text_input("Email:", key="reg_email")
            reg_password = st.text_input("Password:", type="password", key="reg_password")
            confirm_password = st.text_input("Confirm Password:", type="password")          
            if st.form_submit_button("Register"):
                if reg_email and reg_password and confirm_password:
                    if not validate_email(reg_email):
                        st.error("Please enter a valid email address")
                    elif reg_password != confirm_password:
                        st.error("Passwords do not match")
                    elif len(reg_password) < 6:
                        st.error("Password must be at least 6 characters long")
                    else:
                        success, message = register_user(reg_email, reg_password)
                        if success:
                            st.success(message + " Please login with your credentials.")
                        else:
                            st.error(message)
                else:
                    st.error("Please fill in all fields")
def register_user(email, password):
    """Register new user"""
    if not validate_email(email):
        return False, "Invalid email format"    
    conn = get_db_connection()
    if conn is None:
        return False, "Database connection error"    
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT email FROM user_login WHERE email = %s", (email,))
        if cursor.fetchone():
            cursor.close()
            conn.close()
            return False, "Email already registered"        
        cursor.execute("""
            INSERT INTO user_login (email, password) 
            VALUES (%s, %s)
        """, (email, password))        
        conn.commit()
        cursor.close()
        conn.close()
        return True, "Registration successful"
    except psycopg2.Error as e:
        if conn:
            conn.close()
        return False, f"Registration error: {e}"
def validate_email(email):
    """Validate email format"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
def section_8():
    st.header("üéì Section 8: Final Personalized Course Recommendation")

    if "roll_no" not in st.session_state or not st.session_state.roll_no:
        st.warning("Please complete earlier sections first.")
        return

    roll_no = st.session_state.roll_no
    # Initialize session state for this section's video generation
    if 'final_course_generated' not in st.session_state:
        st.session_state.final_course_generated = False
    if 'final_course_content' not in st.session_state:
        st.session_state.final_course_content = ""
    if 'final_video_script' not in st.session_state:
        st.session_state.final_video_script = ""
    if 'final_video_id' not in st.session_state:
        st.session_state.final_video_id = None

    if st.button("üß† Generate Final Course") and not st.session_state.final_course_generated:
        with st.spinner("Generating final personalized course using Gemini..."):
            final_course = run_super_agent_generate_course(roll_no)

        if final_course:
            st.session_state.final_course_content = final_course
            student = get_student_data(roll_no)
            present_domain = student.get("present_domain", "their industry")
            interested_field = student.get("interested_field", "technology")
            student_name = student.get("name", "the learner")
            
            with st.spinner("üé¨ Creating video prompt and script based on your field..."):
                video_script = generate_video_script_from_course_profile(
                    course_text=final_course,
                    present_domain=present_domain,
                    interested_field=interested_field,
                    student_name=student_name
                )
            st.session_state.final_video_script = video_script
            st.session_state.final_course_generated = True
            st.session_state.final_video_id = None # Reset video ID
            st.rerun()
        else:
            st.error("‚ùå Failed to generate course. Please check agent data.")

    if st.session_state.final_course_generated:
        st.success("‚úÖ Personalized course generated successfully!")
        st.markdown("### üìò Recommended Learning Path")
        st.code(st.session_state.final_course_content)
        
        st.markdown("### üé¨ Personalized Video Prompt & Script")
        st.markdown(st.session_state.final_video_script)       
        st.download_button(
            label="üì• Download Video Script",
            data=st.session_state.final_video_script,
            file_name=f"{roll_no}_video_script.txt",
            mime="text/plain"
        )
        # Video Generation Button and Logic
        if st.button("üé¨ Generate Video from Script", key="generate_final_video_button"):
            script_text = ""
            video_output = st.session_state.final_video_script

            if "## üìù Script:" in video_output:
                script_text = video_output.split("## üìù Script:")[1].strip()
            else:
                script_text = video_output # Fallback if marker is not found

            if script_text:
                lines = script_text.split('\n')
                if len(lines) > 3:
                    # Truncate to the first two lines as requested
                    script_text = "\n".join(lines[:3])
                    st.warning("‚ö†Ô∏è Script truncated to the first 3 lines for video generation.")
            
            if not script_text:
                st.error("Could not extract a valid script to generate video.")
            else:
                with st.spinner("Sending script to video generator..."):
                    create_response = create_tavus_video(TAVUS_API_KEY, script_text)

                    if create_response and create_response.get("video_id"):
                        video_id = create_response["video_id"]
                        st.session_state.final_video_id = video_id
                        st.success(f"‚úÖ Video generation started! Video ID: `{video_id}`")
                        st.write("‚è≥ Waiting for video to be ready... This can take a few minutes.")

                        video_url = None
                        max_attempts = 60
                        
                        for attempt in range(max_attempts):
                            status_response = check_tavus_video_status(TAVUS_API_KEY, video_id)
                            
                            if status_response and 'status' in status_response:
                                status = status_response.get("status")
                                st.info(f"Video status: '{status}' (Attempt {attempt + 1}/{max_attempts})")

                                if status == "completed" or status == "ready":
                                    video_url = status_response.get("download_url")
                                    if video_url:
                                        st.success("üéâ Your video is ready!")
                                        st.video(video_url)
                                        break
                                elif status == "failed":
                                    error_message = status_response.get('error', 'Unknown error')
                                    st.error(f"üö´ Video creation failed: {error_message}")
                                    break
                            else:
                                st.warning("Could not retrieve video status. Will retry...")

                            time.sleep(5)

                        if not video_url:
                            st.warning("‚è∞ Video is still processing or may have failed.")

        # Display video if it was generated in a previous run
        if st.session_state.final_video_id and not st.video:
             with st.spinner("Checking status of existing video..."):
                status_response = check_tavus_video_status(TAVUS_API_KEY, st.session_state.final_video_id)
                if status_response and (status_response.get("status") == "completed" or status_response.get("status") == "ready"):
                    video_url = status_response.get("download_url")
                    if video_url:
                        st.success("üéâ Your previously generated video is ready!")
                        st.video(video_url)
def main():
    if 'logged_in' not in st.session_state:
        st.session_state.logged_in = False
    if 'db_initialized' not in st.session_state:
        if create_tables() and create_login_table():
            st.session_state.db_initialized = True
        else:
            st.error("Failed to initialize database.")
            return
    if not st.session_state.logged_in:
        login_page()
        return
    with st.sidebar:
        st.write(f"**Logged in as:** {st.session_state.user_email}")
        if st.button("üìÅ File Upload & Analysis"):
            st.session_state.show_file_upload = True
            st.rerun()      
        if st.button("Logout"):
            st.session_state.logged_in = False
            st.session_state.user_email = None
            for key in list(st.session_state.keys()):
                if key not in ['logged_in', 'user_email', 'db_initialized']:
                    del st.session_state[key]
            st.rerun()
    if st.session_state.get('show_file_upload', False):
        file_upload_section()
        if st.button("‚Üê Back to Main System"):
            st.session_state.show_file_upload = False
            st.rerun()
        return    
    st.title("üéØ Adaptive Quiz & Course System")   
    if 'current_section' not in st.session_state:
        st.session_state.current_section = 1
    if 'roll_no' not in st.session_state:
        st.session_state.roll_no = ""
    if 'section2_level' not in st.session_state:
        st.session_state.section2_level = 3
    if 'section3_level' not in st.session_state:
        st.session_state.section3_level = 3
    with st.sidebar:
        st.header("Navigation")
        sections = [
            "Section 1: Background",
            "Section 2: Cognitive Test", 
            "Section 3: Domain Knowledge",
            "Section 4: Viva Voce",
            "Section 5: Course Configuration",
            "Section 6: Course Learning",
            "Section 7: Analysis",
            "Section 8: Final Course Generation" 
        ]       
        selected_section = st.selectbox("Go to section:", sections, index=st.session_state.current_section - 1)
        if st.button("Navigate"):
            st.session_state.current_section = sections.index(selected_section) + 1
            st.rerun()
    if st.session_state.current_section == 1:
        section_1()
    elif st.session_state.current_section == 2:
        section_2()
    elif st.session_state.current_section == 3:
        section_3()
    elif st.session_state.current_section == 4:
        section_4()
    elif st.session_state.current_section == 5:
        section_5()
    elif st.session_state.current_section == 6:
        section_6()
    elif st.session_state.current_section == 7:
        section_7()
    elif st.session_state.current_section == 8:
        section_8()  
if __name__ == "__main__":
    main()
